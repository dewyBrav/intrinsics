## Intrinsics

### Contents
* `Intrinsics`: встроенные объекты компилятора

## Векторные вычисления — такие вычисления, когда при выполнении одной инструкции процессора производится  одновременно несколько однотипных операций

## Векторные инструкции реализуют те же операции, что и скалярные (обычные) инструкции, но благодаря большому объёму обрабатываемых данных производительность этих инструкций выше. Если для регистра общего назначения при выполнении некоторой инструкции предполагается, что в нём находится только одна порция данных определённого типа (целое число определённой разрядности, число с плавающей запятой), то в векторном регистре одновременно находится столько независимых порций данных определённого типа, сколько позволяет разместить ёмкость регистра. И такое же количество одновременных независимых операций может быть произведено над этими данными при выполнении векторной инструкции — и во столько же раз повышается производительность вычислений. Повысить производительность процессора, выполняя несколько одинаковых операций одновременно, — основная задача векторных расширений.

## Можно получить доступ к векторным инструкциям и в программе на языке высокого уровня (в частности, C/C++) без ассемблерных вставок. Для этого используются так называемые интринсики (intrinsics) — встроенные объекты компилятора. В заголовочном файле объявлен один или несколько типов данных (с точки зрения программиста, это массив фиксированной длины, но без возможности доступа к элементам этого массива), переменной одного из этих типов соответствует векторный регистр

## векторным регистрам xmm (SSE) соответствуют три типа данных [1]:  
## __m128, «массив» из четырёх чисел с плавающей запятой с одинарной точностью; 
## __m128d, «массив» из двух чисел с плавающей запятой двойной точности;
## __m128i, 128-битный регистр, который можно рассматривать как «массив» 8-, 16-,32- и 64-битных чисел. Поскольку конкретная векторная инструкция работает, как правило, с одним из трёх типов данных (число с плавающей запятой одинарной точности, двойной точности, целочисленный), то и аргументы функций-векторных инструкций имеют один из трёх указанных типов. Подобным образом устроена и система типов AVX2: в ней имеются типы __m256 (с плавающей запятой), __m256d (двойной точности) и __m256i (целочисленный).

## Описание intrinsics.cpp
## В этом примере содержимое массива array_a загружается в один векторный регистр, а массива array_b — в другой. Затем соответствующие 32-битные элементы регистров складываются, и результат записывается в третий регистр, а затем копируется в массив array_c. В этом примере можно отметить ещё одну особенность интринсиков: _mm_add_epi32 принимает два аргумента-регистра и возвращает одно значение-регистр. Но в действительности инструкция paddd, которой соответствует _mm_add_epi32, имеет только два регистра-операнда, в один из которых записывается результат операции с потерей первоначального содержимого регистра. Чтобы сохранить содержимое регистров при компиляции c = _mm_add_epi32(a, b), компилятор добавляет дополнительные операции копирования из регистра в регистр
## Имена интринсиков выбраны так, чтобы облегчить чтение исходного текста программ. В архитектуре x86 имя состоит из трёх частей: префикса, обозначений операции и типа скалярных данных(пример _mm_add_epi32). Префикс обозначает разрядность векторного регистра: _mm_ для 128 бит, _mm256_ для 256 бит и _mm512_ для 512 бит соответственно. Обозначения некоторых типов данных приведены в таблице 1. 

## Таблица 1: Обозначение типов данных интринсиков архитектуры х86 (b)
## Обозначение 	Описание
## ps	        Число с плавающей запятой одинарной точности
## pd	        Число с плавающей запятой двойной точности
## epi8	        Целое число, 8 бит, со знаком
## epu8	        Целое число, 8 бит, без знака
## epi16	    Целое число, 16 бит, со знаком
## epi32	    Целое число, 32 бит, со знаком
## epi64	    Целое число, 64 бит, со знаком
## si128	    Целое число, 128 бит
## si256	    Целое число, 256 бит
## Имена типов данных (__m128i и другие) и имена функций-интринсиков фактически стали стандартными в разных компиляторах

##